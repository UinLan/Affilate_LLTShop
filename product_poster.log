import os
import sys
import io
import time
import random
import argparse
import logging
import requests
from pymongo import MongoClient
import facebook
from datetime import datetime, timedelta
from dotenv import load_dotenv
from bson import ObjectId
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import json

sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('product_poster.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

class ContentGenerator:
    def __init__(self):
        self._load_content_templates()
        self._init_emoji_patterns()

    def _load_content_templates(self):
        self.templates = [
            "üåü {productName} - S·∫£n ph·∫©m ch·∫•t l∆∞·ª£ng cao!\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "üî• {productName} - L·ª±a ch·ªçn ho√†n h·∫£o cho b·∫°n!\n{emoji}\n{hashtags}\n\nMua ngay: {affiliateLink}",
            "üì¢ ƒê·ª´ng b·ªè l·ª°: {productName} {emoji}\n{hashtags}\n\n{affiliateLink}",
            "üéØ {productName} - Gi·∫£i ph√°p tuy·ªát v·ªùi cho nhu c·∫ßu c·ªßa b·∫°n\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "üö® {productName} - S·∫£n ph·∫©m ƒë∆∞·ª£c y√™u th√≠ch!\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "B·∫°n ƒë√£ th·ª≠ {productName} ch∆∞a? {emoji}\n{hashtags}\n\n{affiliateLink}",
            "{productName} - Tr·∫£i nghi·ªám m·ªõi m·∫ª ƒëang ch·ªù b·∫°n!\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "Kh√°m ph√° ngay {productName} - S·∫£n ph·∫©m ƒë√°ng ƒë·ªÉ th·ª≠!\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "{productName} - L·ª±a ch·ªçn th√¥ng minh cho cu·ªôc s·ªëng hi·ªán ƒë·∫°i\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "ƒê√£ ƒë·∫øn l√∫c n√¢ng c·∫•p tr·∫£i nghi·ªám v·ªõi {productName} {emoji}\n{hashtags}\n\n{affiliateLink}",
            "{productName} - S·∫£n ph·∫©m kh√¥ng th·ªÉ thi·∫øu trong ƒë·ªùi s·ªëng h·∫±ng ng√†y\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "B·∫°n s·∫Ω ·∫•n t∆∞·ª£ng v·ªõi ch·∫•t l∆∞·ª£ng c·ªßa {productName} {emoji}\n{hashtags}\n\n{affiliateLink}",
            "{productName} - Mang ƒë·∫øn s·ª± kh√°c bi·ªát r√µ r·ªát\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "Tr·∫£i nghi·ªám tuy·ªát v·ªùi c√πng {productName} {emoji}\n{hashtags}\n\n{affiliateLink}",
            "{productName} - S·ª± k·∫øt h·ª£p ho√†n h·∫£o gi·ªØa ch·∫•t l∆∞·ª£ng v√† ti·ªán √≠ch\n{emoji}\n{hashtags}\n\n{affiliateLink}",
            "Kh√°m ph√° ngay {productName} - S·∫£n ph·∫©m ƒë√°ng ƒë·ªÉ s·ªü h·ªØu\n{emoji}\n{hashtags}\n\n{affiliateLink}"
        ]
        
        self.hashtags = [
            "#SanPhamHot #DealHot #UuDai",
            "#MuaSamOnline #ShopOnline #HangChatLuong",
            "#AffiliateMarketing #ReviewSanPham #KhuyenMai"
        ]

    def _init_emoji_patterns(self):
        self.emoji_patterns = {
            'excited': ["üî•", "‚ú®", "üéâ", "üöÄ"],
            'happy': ["üòç", "ü•∞", "üòä", "üëç"],
            'shopping': ["üõçÔ∏è", "üõí", "üí∞", "üí≥"],
            'quality': ["‚≠ê", "üèÜ", "üíé", "üëë"]
        }

    def generate_hashtags(self):
        base_tags = ["SanPhamHot", "MuaSamOnline", "Affiliate"]
        custom_tags = random.sample([
            "DealHot", "HangChinhHang", "GiaTot", 
            "KhuyenMai", "Review", "ShopOnline",
            "ChatLuong", "UuDai", "HangMoi"
        ], 3)
        return " ".join(["#" + tag for tag in base_tags + custom_tags])

    def generate_emoji_sequence(self):
        mood = random.choice(list(self.emoji_patterns.keys()))
        return " ".join(random.sample(self.emoji_patterns[mood], 2))

    def generate_caption(self, product):
        product_name = product.get("productName", "S·∫£n ph·∫©m ch·∫•t l∆∞·ª£ng")
        affiliate_link = product.get("affiliateLink", "")
        
        if not affiliate_link:
            raise ValueError("Affiliate link is required for product posting")
            
        template = random.choice(self.templates)

        variables = {
            "productName": product_name,
            "emoji": self.generate_emoji_sequence(),
            "hashtags": self.generate_hashtags(),
            "affiliateLink": affiliate_link
        }

        caption = template.format(**variables)
        return caption

class FacebookPoster:
    def __init__(self):
        load_dotenv()
        self._validate_environment()
        self._init_clients()
        self.content_gen = ContentGenerator()

    def _validate_environment(self):
        required = ['MONGODB_URI', 'FACEBOOK_ACCESS_TOKEN', 'FACEBOOK_PAGE_ID']
        missing = [k for k in required if not os.getenv(k)]
        if missing:
            raise EnvironmentError(f"Missing env vars: {', '.join(missing)}")

    def _init_clients(self):
        self.mongo_client = MongoClient(os.getenv("MONGODB_URI"))
        db = self.mongo_client.get_database("auto_post")
        self.products_col = db["products"]
        self.post_history_col = db["post_history"]
        self.graph = facebook.GraphAPI(access_token=os.getenv("FACEBOOK_ACCESS_TOKEN"), version="3.0")
        self.fb_page_id = os.getenv("FACEBOOK_PAGE_ID")

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(min=2, max=10), retry=retry_if_exception_type(Exception))
    def _upload_images(self, image_urls):
        uploaded = []
        for url in image_urls[:4]:
            try:
                resp = requests.get(url, stream=True, timeout=10)
                resp.raise_for_status()
                res = self.graph.put_photo(
                    image=resp.raw,
                    album_path=f"{self.fb_page_id}/photos",
                    published=False
                )
                uploaded.append({"media_fbid": res["id"]})
            except Exception as e:
                logging.warning(f"Image upload failed: {e}")
        if not uploaded:
            raise Exception("No images uploaded")
        return uploaded

    def process_product(self, product_id):
        product = self.products_col.find_one({"_id": ObjectId(product_id)})
        if not product:
            return False

        try:
            caption = self.content_gen.generate_caption(product)
        except ValueError as e:
            logging.error(f"Skipping product {product_id}: {str(e)}")
            return False

        images = product.get("images", [])
        if not images:
            return False

        selected = random.sample(images, min(len(images), 4))
        
        try:
            uploaded = self._upload_images(selected)
            attached_media = [{"media_fbid": media["media_fbid"]} for media in uploaded]
            
            post_args = {
                "message": caption,
                "attached_media": json.dumps(attached_media),
                "published": True
            }

            post = self.graph.request(
                f"{self.fb_page_id}/feed",
                method="POST",
                post_args=post_args
            )
            
            self.post_history_col.insert_one({
                "productId": product["_id"],
                "postId": post["id"],
                "timestamp": datetime.utcnow(),
                "caption": caption,
                "imagesUsed": len(uploaded),
                "affiliateLink": product.get("affiliateLink", "")
            })
            
            self.products_col.update_one(
                {"_id": product["_id"]},
                {"$set": {"lastPosted": datetime.utcnow()}}
            )
            
            return True
        except Exception as e:
            logging.error(f"Failed to post product {product_id}: {str(e)}")
            return False

    def run_as_service(self):
        while True:
            try:
                query = {
                    "$or": [
                        {"postedHistory": {"$exists": False}},
                        {"lastPosted": {"$lt": datetime.utcnow() - timedelta(days=5)}}
                    ],
                    "images": {"$ne": [], "$exists": True},
                    "affiliateLink": {"$exists": True, "$ne": ""}
                }

                products = list(self.products_col.find(query).limit(random.randint(1, 3)))
                for p in products:
                    success = self.process_product(str(p["_id"]))
                    if success:
                        time.sleep(random.randint(120, 300))
                time.sleep(random.randint(1800, 3600))
            except KeyboardInterrupt:
                logging.info("Service stopped by user")
                break
            except Exception as e:
                logging.error(f"Service error: {str(e)}")
                time.sleep(600)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--product-id', help='Process one product by ID')
    parser.add_argument('--test-content', action='store_true')
    args = parser.parse_args()

    bot = FacebookPoster()

    if args.test_content:
        sample = {
            "productName": "√Åo thun c·ªï tr√≤n in h√¨nh",
            "affiliateLink": "https://example.com/affiliate-link",
            "images": ["https://example.com/image1.jpg"]
        }
        for i in range(5):
            print(f"\nCaption {i+1}:\n{bot.content_gen.generate_caption(sample)}")
    elif args.product_id:
        bot.process_product(args.product_id)
    else:
        bot.run_as_service()